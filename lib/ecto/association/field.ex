defmodule Ecto.Schema.Field do
  import Ecto.Association.Options, only: [check!: 4, put_struct_field: 3]

  @doc false
  def __define__(mod, name, type, opts) do
    # Check the field type before we check options because it is
    # better to raise unknown type first than unsupported option.
    type = check_field_type!(mod, name, type, opts)
    if type == :any && !opts[:virtual] do
      raise ArgumentError,
            "only virtual fields can have type :any, " <>
              "invalid type for field #{inspect(name)}"
    end
    check!(:field, type, opts, "field/3")
    opt_in!(:default, mod, name, type, opts)
    define_field(mod, name, type, opts)
    Module.put_attribute(mod, :ecto_changeset_fields, {name, type})
  end

  def define_field(mod, name, type, opts) do
    opts = opts
    |> Keyword.put_new(:redact, should_redact?(mod, opts))
    |> Keyword.put_new(:source, Module.get_attribute(mod, :field_source_mapper, &Function.identity/1).(name))
    |> Keyword.put_new(:writable, :always)
    |> Keyword.put_new(:load_in_query, true)
    |> Keyword.put_new(:virtual, false)
    |> Keyword.put_new(:primary_key, false)

    [:redact, :virtual, :source, :read_after_writes, :writable, :primary_key, :load_in_query, :autogenerate]
    |> Enum.reduce(mod, fn option, mod -> opt_in!(option, mod, name, type, opts) end)

    put_struct_field(mod, name, opts[:default])
  end

  defp store_mfa_autogenerate!(mod, name, type, mfa) do
    if autogenerate_id?(type) do
      raise ArgumentError, ":autogenerate with {m, f, a} not supported by ID types"
    end

    Module.put_attribute(mod, :ecto_autogenerate, {[name], mfa})
  end

  def should_redact?(mod, opts) do
    case Module.get_attribute(mod, :schema_redact, false) do
      :all_except_primary_keys -> not (opts[:primary_key] || false)
      _ -> false
    end
  end

  def ensure_consistent_autogenerate_options(opts) do
    case opts[:autogenerate] do
      {_, _, _} ->
      if opts[:read_after_writes] do
        raise ArgumentError, "cannot mark the same field as autogenerate and read_after_writes"
      end
      if opts[:writeable] != :always do
        raise ArgumentError, "autogenerated fields must always be writable"
      end
      _ -> :ok
    end
    opts
  end

  def opt_in!(option_name, mod, name, type, opts) do
    opt_in!(option_name, opts[option_name], mod, name, type, opts)
    mod
  end

  def opt_in!(:writable, writable, _mod, _name, _type, opts) do
    if writable != :always && opts[:autogenerate] do
      raise ArgumentError, "autogenerated fields must always be writable"
    end
  end

  def opt_in!(:primary_key, true, mod, name, _type, _opts)  do
    Module.put_attribute(mod, :ecto_primary_keys, name)
  end

  def opt_in!(:virtual, true, mod, name, type, _opts) do
    Module.put_attribute(mod, :ecto_virtual_fields, {name, type})
  end

  def opt_in!(:virtual, false, mod, name, type, opts) do
    Module.put_attribute(mod, :ecto_fields, {name, {type, opts[:writable]}})
  end

  def opt_in!(:source, source, mod, name, _type, opts) when is_atom(source) do
    unless opts[:virtual] or name == source do
      Module.put_attribute(mod, :ecto_field_sources, {name, source})
    end
  end

  def opt_in!(:source, source, _mod, name, _type, opts) when not is_atom(source) do
    unless opts[:virtual] do
      raise ArgumentError,
        "the :source for field `#{name}` must be an atom, got: #{inspect(source)}"
      end
  end

  def opt_in!(:read_after_writes, true, mod, name, _type, opts) do
    if opts[:autogenerate] do
      raise ArgumentError, "cannot mark the same field as autogenerate and read_after_writes"
    end
    unless opts[:virtual] do
      Module.put_attribute(mod, :ecto_raw, name)
    end
  end

  def opt_in!(:autogenerate, {_, _, _} = gen, mod, name, type, _opts) do
    store_mfa_autogenerate!(mod, name, type, gen)
  end

  def opt_in!(:autogenerate, true, mod, name, type, opts) do
    store_type_autogenerate!(mod, name, opts[:source] || name, type, opts[:primary_key])
  end

  def opt_in!(:load_in_query, true, mod, name, type, opts) do
    unless opts[:virtual] do
      Module.put_attribute(mod, :ecto_query_fields, {name, type})
    end
  end

  def opt_in!(:load_in_query, false, _mod, _, _, _opts) do
  end

  def opt_in!(:redact, true, mod, name, _type, _opts) do
    Module.put_attribute(mod, :ecto_redact_fields, name)
  end

  def opt_in!(:default, value, _mod, _name, type, opts) do
    unless opts[:skip_default_validation] do
      case Ecto.Type.dump(type, value) do
        {:ok, _} ->
          :ok

        _ ->
          raise ArgumentError,
                "value #{inspect(value)} is invalid for type #{Ecto.Type.format(type)}, can't set default"
      end
    end
  end

  def opt_in!(_option, _value, _mod, _name, _type, _opts) do
  end

  def check_field_type!(_mod, name, :datetime, _opts) do
    raise ArgumentError,
          "invalid type :datetime for field #{inspect(name)}. " <>
            "You probably meant to choose one between :naive_datetime " <>
            "(no time zone information) or :utc_datetime (time zone is set to UTC)"
  end

  def check_field_type!(mod, name, type, opts) do
    cond do
      composite?(type, name) ->
        {outer_type, inner_type} = type
        {outer_type, check_field_type!(mod, name, inner_type, opts)}

      not is_atom(type) ->
        raise ArgumentError, "invalid type #{Ecto.Type.format(type)} for field #{inspect(name)}"

      Ecto.Type.base?(type) ->
        type

      Code.ensure_compiled(type) == {:module, type} ->
        cond do
          function_exported?(type, :type, 0) ->
            type

          function_exported?(type, :type, 1) ->
            Ecto.ParameterizedType.init(type, Keyword.merge(opts, field: name, schema: mod))

          function_exported?(type, :__schema__, 1) ->
            raise ArgumentError,
                  "schema #{inspect(type)} is not a valid type for field #{inspect(name)}." <>
                    " Did you mean to use belongs_to, has_one, has_many, embeds_one, or embeds_many instead?"

          true ->
            raise ArgumentError,
                  "module #{inspect(type)} given as type for field #{inspect(name)} is not an Ecto.Type/Ecto.ParameterizedType"
        end

      true ->
        raise ArgumentError, "unknown type #{inspect(type)} for field #{inspect(name)}"
    end
  end

  defp composite?({composite, _} = type, name) do
    if Ecto.Type.composite?(composite) do
      true
    else
      raise ArgumentError,
            "invalid or unknown composite #{inspect(type)} for field #{inspect(name)}. " <>
              "Did you mean to use :array or :map as first element of the tuple instead?"
    end
  end

  defp composite?(_type, _name), do: false


  def store_type_autogenerate!(mod, name, source, {:parameterized, typemod_params} = type, pk?) do
    {typemod, params} = typemod_params

    cond do
      store_autogenerate_id!(mod, name, source, type, pk?) ->
        :ok

      not function_exported?(typemod, :autogenerate, 1) ->
        raise ArgumentError,
              "field #{inspect(name)} does not support :autogenerate because it uses a " <>
                "parameterized type #{Ecto.Type.format(type)} that does not define autogenerate/1"

      true ->
        Module.put_attribute(
          mod,
          :ecto_autogenerate,
          {[name], {typemod, :autogenerate, [params]}}
        )
    end
  end

  def store_type_autogenerate!(mod, name, source, type, pk?) do
    cond do
      store_autogenerate_id!(mod, name, source, type, pk?) ->
        :ok

      Ecto.Type.primitive?(type) ->
        raise ArgumentError,
              "field #{inspect(name)} does not support :autogenerate because it uses a " <>
                "primitive type #{Ecto.Type.format(type)}"

      # Note the custom type has already been loaded in check_type!/3
      not function_exported?(type, :autogenerate, 0) ->
        raise ArgumentError,
              "field #{inspect(name)} does not support :autogenerate because it uses a " <>
                "custom type #{Ecto.Type.format(type)} that does not define autogenerate/0"

      true ->
        Module.put_attribute(mod, :ecto_autogenerate, {[name], {type, :autogenerate, []}})
    end
  end

  defp store_autogenerate_id!(mod, name, source, type, pk?) do
    cond do
      not autogenerate_id?(type) ->
        false

      not pk? ->
        raise ArgumentError,
              "only primary keys allow :autogenerate for type #{Ecto.Type.format(type)}, " <>
                "field #{inspect(name)} is not a primary key"

      Module.get_attribute(mod, :ecto_autogenerate_id) ->
        raise ArgumentError, "only one primary key with ID type may be marked as autogenerated"

      true ->
        Module.put_attribute(mod, :ecto_autogenerate_id, {name, source, type})
        true
    end
  end

  defp autogenerate_id?(type), do: Ecto.Type.type(type) in [:id, :binary_id]
end
